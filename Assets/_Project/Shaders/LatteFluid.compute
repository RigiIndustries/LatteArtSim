// LatteFluid.compute
// 2D stable fluid + dye simulation for latte art.
// - Semi-Lagrangian advection (velocity + dye)
// - Pressure projection (divergence → Jacobi → subtract gradient)
// - Circular cup mask in UV space + free-slip rim handling
//
// Conventions:
// - UV space is [0..1] across the simulation grid.
// - Cup is a disc centered at (0.5, 0.5) with radius CUP_RADIUS.
// - Outside cup: velocity/dye/pressure are cleared.
// - Rim band: removes normal velocity (free-slip) and damps tangential velocity.
//
// Note: jacobiAlpha/jacobiBeta are kept for C# API compatibility but unused here.

#pragma kernel Splat
#pragma kernel Advect
#pragma kernel AdvectDye
#pragma kernel DiffuseVel
#pragma kernel ComputeDiv
#pragma kernel JacobiPressure
#pragma kernel SubtractGrad
#pragma kernel Boundary
#pragma kernel TestFill

#define THREADS 8

// ===================== RW targets (ping-pong pairs) =====================

// Velocity (u, v)
RWTexture2D<float2> VelRead;
RWTexture2D<float2> VelWrite;

// Dye (latte color / milk). We mainly use rgb.
RWTexture2D<float4> DyeRead;
RWTexture2D<float4> DyeWrite;

// Pressure and divergence
RWTexture2D<float> PressureRead;
RWTexture2D<float> PressureWrite;
RWTexture2D<float> Divergence;

// For velocity diffusion (original/source velocity field)
RWTexture2D<float2> Vel0;

// ===================== Parameters =====================

cbuffer FluidParams
{
    int2  GridSize;       // resolution (width, height)
    float dt;             // timestep (seconds)

    float viscosity;      // viscosity for DiffuseVel
    float dyeDissipation; // dye fade per second

    // Splat (pour) parameters
    float2 splatUV;       // center of pour in [0,1]^2
    float  splatRadius;   // radius in UV space
    float  splatHardness; // 0..1, controls splat edge
    float  splatAmount;   // how much dye/milk to add
    float2 splatForce;    // velocity impulse (UV/sec)

    float jacobiAlpha;    // unused (kept for compatibility)
    float jacobiBeta;     // unused (kept for compatibility)
};

// ===================== Cup constants (UV space) =====================
// Adjust CUP_RADIUS slightly if your cup mesh doesn’t fill the whole disc.

static const float2 CUP_CENTER    = float2(0.5, 0.5);
static const float  CUP_RADIUS    = 0.49;    // radius in UV
static const float  CUP_RIM_WIDTH = 0.012;   // thickness of rim band (UV) where flow is clamped

// ===================== Helpers =====================

int2 Dim()
{
    return GridSize;
}

bool InBounds(int2 p)
{
    return (p.x >= 0 && p.y >= 0 && p.x < GridSize.x && p.y < GridSize.y);
}

int2 ClampCoord(int2 p)
{
    int2 minC = int2(0, 0);
    int2 maxC = GridSize - int2(1, 1);
    return clamp(p, minC, maxC);
}

float2 UVFromCoord(int2 p)
{
    return (float2(p) + 0.5) / float2(GridSize);
}

// Soft circular mask for splat shapes (not the cup boundary).
float circleMask(float2 uv, float2 center, float radius, float hardness)
{
    float d    = distance(uv, center);
    float rIn  = radius * (1.0 - hardness);
    float rOut = radius;

    float m = saturate(smoothstep(rOut, rIn, d));
    return m;
}

// Cup mask in UV (1 inside cup, 0 outside, sharp).
float CupMaskFromUV(float2 uv)
{
    float d = distance(uv, CUP_CENTER);
    return (d <= CUP_RADIUS) ? 1.0 : 0.0;
}

float CupMaskAtCoord(int2 p)
{
    float2 uv = UVFromCoord(p);
    return CupMaskFromUV(uv);
}

// ===================== Texture read helpers =====================

float2 readVel(int2 p)
{
    p = ClampCoord(p);
    return VelRead[p];
}

float4 readDye(int2 p)
{
    p = ClampCoord(p);
    return DyeRead[p];
}

float readP(int2 p)
{
    p = ClampCoord(p);
    return PressureRead[p];
}

float readDiv(int2 p)
{
    p = ClampCoord(p);
    return Divergence[p];
}

// ===================== Bilinear sampling in UV space =====================

float2 bilerpVel(float2 uv)
{
    float2 coord = uv * float2(GridSize) - 0.5;
    int2   p0    = (int2)floor(coord);
    float2 f     = frac(coord);

    int2 p00 = ClampCoord(p0);
    int2 p10 = ClampCoord(p0 + int2(1, 0));
    int2 p01 = ClampCoord(p0 + int2(0, 1));
    int2 p11 = ClampCoord(p0 + int2(1, 1));

    float2 v00 = VelRead[p00];
    float2 v10 = VelRead[p10];
    float2 v01 = VelRead[p01];
    float2 v11 = VelRead[p11];

    float2 v0 = lerp(v00, v10, f.x);
    float2 v1 = lerp(v01, v11, f.x);

    return lerp(v0, v1, f.y);
}

float4 bilerpDye(float2 uv)
{
    float2 coord = uv * float2(GridSize) - 0.5;
    int2   p0    = (int2)floor(coord);
    float2 f     = frac(coord);

    int2 p00 = ClampCoord(p0);
    int2 p10 = ClampCoord(p0 + int2(1, 0));
    int2 p01 = ClampCoord(p0 + int2(0, 1));
    int2 p11 = ClampCoord(p0 + int2(1, 1));

    float4 c00 = DyeRead[p00];
    float4 c10 = DyeRead[p10];
    float4 c01 = DyeRead[p01];
    float4 c11 = DyeRead[p11];

    float4 c0 = lerp(c00, c10, f.x);
    float4 c1 = lerp(c01, c11, f.x);

    return lerp(c0, c1, f.y);
}

// Semi-Lagrangian backtrace in UV space.
float2 backtrace(float2 uv)
{
    float2 v = bilerpVel(uv);
    return uv - v * dt;
}

// ===================== Kernels =====================

// TestFill: quick visual test (soft circle in center, inside cup only).
[numthreads(THREADS, THREADS, 1)]
void TestFill(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        DyeWrite[p] = float4(0,0,0,1);
        return;
    }

    float2 c = float2(0.5, 0.5);
    float  r = 0.35;
    float  m = smoothstep(r, r - 0.01, distance(uv, c));

    m *= maskCup;
    DyeWrite[p] = float4(m, m, m, 1);
}

// Splat: add dye and apply a velocity impulse, clamped to cup.
[numthreads(THREADS, THREADS, 1)]
void Splat(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        DyeWrite[p] = float4(0,0,0,1);
        VelWrite[p] = float2(0,0);
        return;
    }

    float m = circleMask(uv, splatUV, splatRadius, splatHardness) * splatAmount;
    m *= maskCup; // no splat outside cup

    float4 c = readDye(p);
    c.rgb = saturate(c.rgb + m.xxx);
    c.a   = 1.0;
    DyeWrite[p] = c;

    float2 v = readVel(p);
    v += splatForce * m;
    VelWrite[p] = v;
}

// Advect velocity with itself (semi-Lagrangian), staying inside cup.
// Circular rim constraints are applied later in Boundary().
[numthreads(THREADS, THREADS, 1)]
void Advect(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        VelWrite[p] = float2(0,0);
        return;
    }

    float2 prevUV = backtrace(uv);
    float2 v      = bilerpVel(prevUV);

    VelWrite[p] = v; // circular boundary handled later in Boundary()
}

// Advect dye by velocity + exponential fade, staying inside cup.
[numthreads(THREADS, THREADS, 1)]
void AdvectDye(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        DyeWrite[p] = float4(0,0,0,1);
        return;
    }

    float2 prevUV = backtrace(uv);
    float4 c      = bilerpDye(prevUV);

    float fade = exp(-saturate(dyeDissipation) * dt);
    c.rgb *= fade;
    c.a   = 1.0;

    DyeWrite[p] = c;
}

// DiffuseVel: Jacobi diffusion on velocity using Vel0 as the source field, inside cup.
[numthreads(THREADS, THREADS, 1)]
void DiffuseVel(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        VelWrite[p] = float2(0,0);
        return;
    }

    int2 left  = ClampCoord(p + int2(-1,  0));
    int2 right = ClampCoord(p + int2( 1,  0));
    int2 down  = ClampCoord(p + int2( 0, -1));
    int2 up    = ClampCoord(p + int2( 0,  1));

    float2 vL = VelRead[left];
    float2 vR = VelRead[right];
    float2 vD = VelRead[down];
    float2 vU = VelRead[up];

    float2 v0 = Vel0[p];

    float a     = viscosity * dt;
    float denom = 1.0 + 4.0 * a;

    float2 vNew = (v0 + a * (vL + vR + vD + vU)) / denom;

    VelWrite[p] = vNew;
}

// Compute divergence for incompressibility solve, inside cup.
[numthreads(THREADS, THREADS, 1)]
void ComputeDiv(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        Divergence[p] = 0.0;
        return;
    }

    int2 left  = ClampCoord(p + int2(-1,  0));
    int2 right = ClampCoord(p + int2( 1,  0));
    int2 down  = ClampCoord(p + int2( 0, -1));
    int2 up    = ClampCoord(p + int2( 0,  1));

    float2 vL = readVel(left);
    float2 vR = readVel(right);
    float2 vD = readVel(down);
    float2 vU = readVel(up);

    float div = 0.5 * (
        (vR.x - vL.x) +
        (vU.y - vD.y)
    );

    Divergence[p] = div;
}

// Jacobi relaxation to solve for pressure, inside cup.
[numthreads(THREADS, THREADS, 1)]
void JacobiPressure(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        PressureWrite[p] = 0.0;
        return;
    }

    int2 left  = ClampCoord(p + int2(-1,  0));
    int2 right = ClampCoord(p + int2( 1,  0));
    int2 down  = ClampCoord(p + int2( 0, -1));
    int2 up    = ClampCoord(p + int2( 0,  1));

    float pL = readP(left);
    float pR = readP(right);
    float pD = readP(down);
    float pU = readP(up);

    float div = readDiv(p);

    float pNew = (pL + pR + pD + pU - div) * 0.25;

    PressureWrite[p] = pNew;
}

// Subtract pressure gradient from velocity (projection), inside cup.
[numthreads(THREADS, THREADS, 1)]
void SubtractGrad(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    float2 uv      = UVFromCoord(p);
    float  maskCup = CupMaskFromUV(uv);
    if (maskCup <= 0.0)
    {
        VelWrite[p] = float2(0,0);
        return;
    }

    int2 left  = ClampCoord(p + int2(-1,  0));
    int2 right = ClampCoord(p + int2( 1,  0));
    int2 down  = ClampCoord(p + int2( 0, -1));
    int2 up    = ClampCoord(p + int2( 0,  1));

    float pL = readP(left);
    float pR = readP(right);
    float pD = readP(down);
    float pU = readP(up);

    float2 v = readVel(p);

    float2 gradP;
    gradP.x = 0.5 * (pR - pL);
    gradP.y = 0.5 * (pU - pD);

    v -= gradP;
    VelWrite[p] = v;
}

// Boundary:
// 1) hard zero at outer grid edges (square)
// 2) circular free-slip rim: kill normal velocity, keep tangential,
//    and damp tangential speed so the flow hugs the edge.
[numthreads(THREADS, THREADS, 1)]
void Boundary(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!InBounds(p)) return;

    int2 dim = Dim();

    // 1) hard zero on outer square border
    if (p.x == 0 || p.y == 0 || p.x == dim.x - 1 || p.y == dim.y - 1)
    {
        VelWrite[p]      = float2(0, 0);
        PressureWrite[p] = 0;
        return;
    }

    // 2) circular rim handling
    float2 uv = UVFromCoord(p);
    float  d  = distance(uv, CUP_CENTER);

    float2 v  = VelWrite[p];

    // Outside cup: zero everything
    if (d > CUP_RADIUS)
    {
        VelWrite[p]      = float2(0,0);
        PressureWrite[p] = 0;
        return;
    }

    // Near rim: free-slip + damping
    if (d > CUP_RADIUS - CUP_RIM_WIDTH)
    {
        float2 n  = normalize(uv - CUP_CENTER); // outward normal
        float  vn = dot(v, n);
        float2 vt = v - vn * n;                 // tangential component only

        float rimDamping = 0.6;                 // < 1 slows flow at the rim
        v = vt * rimDamping;

        VelWrite[p] = v;
    }
    // interior: leave as is
}
